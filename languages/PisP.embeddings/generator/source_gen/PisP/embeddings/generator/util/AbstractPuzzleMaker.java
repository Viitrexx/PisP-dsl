package PisP.embeddings.generator.util;

/*Generated by MPS */

import jetbrains.mps.generator.template.TemplateQueryContext;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class AbstractPuzzleMaker {
  private TemplateQueryContext gc;

  public AbstractPuzzleMaker(TemplateQueryContext gc) {
    this.gc = gc;
  }

  private class listDict {
    private Map<String, listDict> dct;
    private Boolean leaf;
    private String val;

    private listDict() {
      dct = new HashMap<>();
      leaf = false;
      val = null;
    }

    public void add(List<String> lst, String val) {
      listDict listdct = this;
      for (int i = 0; i < ListSequence.fromList(lst).count() - 1; i++) {
        if (!(listdct.dct.containsKey(ListSequence.fromList(lst).getElement(i)))) {
          listdct.dct.put(ListSequence.fromList(lst).getElement(i), new listDict());
        }
        listdct = listdct.dct.get(ListSequence.fromList(lst).getElement(i));
      }
      listDict leafDict = new listDict();
      leafDict.leaf = true;
      leafDict.val = val;
      listdct.dct.put(ListSequence.fromList(lst).getElement(ListSequence.fromList(lst).count() - 1), leafDict);
    }

    public List<String> gets(List<List<String>> lst) {
      List<String> vals = ListSequence.fromList(new ArrayList<String>());
      for (List<String> ls : ListSequence.fromList(lst)) {
        listDict listdct = this;
        for (int i = 0; i < ListSequence.fromList(ls).count(); i++) {
          listdct = listdct.dct.get(ListSequence.fromList(ls).getElement(i));
        }
        ListSequence.fromList(vals).addElement(listdct.val);
      }
      return vals;
    }
  }

  public AbstractPuzzle makeAbstractPuzzle(SNode node) {
    AbstractPuzzle ap = new AbstractPuzzle();
    List<List<Integer>> shapeLocations = mapLocationsToListOfInts(SLinkOperations.getChildren(SLinkOperations.getTarget(node, LINKS.shape$f2Vs), LINKS.locations$c$Xv));

    listDict fieldAspects = new listDict();
    int c = 0;
    for (List<Integer> field : ListSequence.fromList(shapeLocations)) {
      SNode aspectNode = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf18355ad2d424a0aL, 0xa78566932d080030L, 0x4eaa6535d7c8b0a3L, "PisP.embeddings.structure.Aspect"));
      SPropertyOperations.assign(aspectNode, PROPS.name$MnvL, Integer.toString(c));
      ListSequence.fromList(ap.aspects).addElement(aspectNode);
      fieldAspects.add(ListSequence.fromList(field).select(new ISelector<Integer, String>() {
        public String select(Integer it) {
          return ((String) Integer.toString(it));
        }
      }).toListSequence(), Integer.toString(c++));
    }

    // Should I sort the list of locations?
    for (List<Integer> loc : ListSequence.fromList(shapeLocations)) {
      for (SNode op_ref : ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(node, LINKS.bagofpieces$Ua4q), LINKS.pieces$2_Tv))) {
        final SNode op = (SNode) SLinkOperations.getTarget(op_ref, LINKS.piece$jZYy);
        for (SNode orientation : ListSequence.fromList(SLinkOperations.getChildren(op, LINKS.orientations$BxMn))) {
          if (SPropertyOperations.getBoolean(orientation, PROPS.allowed$EpHE)) {
            List<List<Integer>> orient = mapLocationsToListOfInts(SLinkOperations.getChildren(orientation, LINKS.locations$ChQi));
            List<List<Integer>> e = fit(loc, orient, shapeLocations);
            if (ListSequence.fromList(e).isNotEmpty()) {
              for (final Wrappers._int i = new Wrappers._int(0); i.value < SPropertyOperations.getInteger(op_ref, PROPS.multiplicity$Equw); i.value++) {
                SNode embeddingNode = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf18355ad2d424a0aL, 0xa78566932d080030L, 0x4eaa6535d7c8b4ebL, "PisP.embeddings.structure.Embedding"));
                List<List<String>> es = ListSequence.fromList(new ArrayList<List<String>>());
                for (List<Integer> ee : ListSequence.fromList(e)) {
                  List<String> ees = ListSequence.fromList(new ArrayList<String>());
                  for (int eee : ee) {
                    ListSequence.fromList(ees).addElement(Integer.toString(eee));
                  }
                  ListSequence.fromList(es).addElement(ees);
                }
                for (String ee : fieldAspects.gets(es)) {
                  SNode aspectNode = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf18355ad2d424a0aL, 0xa78566932d080030L, 0x4eaa6535d7c8b0a3L, "PisP.embeddings.structure.Aspect"));
                  SPropertyOperations.assign(aspectNode, PROPS.name$MnvL, ee);
                  ListSequence.fromList(SLinkOperations.getChildren(embeddingNode, LINKS.aspects$q3wJ)).addElement(aspectNode);
                }
                SNode pieceAspect = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf18355ad2d424a0aL, 0xa78566932d080030L, 0x4eaa6535d7c8b0a3L, "PisP.embeddings.structure.Aspect"));
                SPropertyOperations.assign(pieceAspect, PROPS.name$MnvL, SPropertyOperations.getString(op, PROPS.name$MnvL) + i.value);
                ListSequence.fromList(SLinkOperations.getChildren(embeddingNode, LINKS.aspects$q3wJ)).addElement(pieceAspect);
                ListSequence.fromList(ap.embeddings).addElement(embeddingNode);
                if (!(ListSequence.fromList(ap.aspects).any(new IWhereFilter<SNode>() {
                  public boolean accept(SNode it) {
                    return SPropertyOperations.getString(it, PROPS.name$MnvL).equals(SPropertyOperations.getString(op, PROPS.name$MnvL) + i.value);
                  }
                }))) {
                  SNode aspectNode = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf18355ad2d424a0aL, 0xa78566932d080030L, 0x4eaa6535d7c8b0a3L, "PisP.embeddings.structure.Aspect"));
                  SPropertyOperations.assign(aspectNode, PROPS.name$MnvL, SPropertyOperations.getString(op, PROPS.name$MnvL) + i.value);
                  ListSequence.fromList(ap.aspects).addElement(aspectNode);
                }
              }
            }
          }
        }
      }
    }
    return ap;
  }

  private List<List<Integer>> fit(List<Integer> loc, List<List<Integer>> orientation, List<List<Integer>> locations) {
    List<Integer> fix = ListSequence.fromList(orientation).getElement(0);
    List<List<Integer>> embedded = ListSequence.fromList(new ArrayList<List<Integer>>());
    ListSequence.fromList(embedded).addElement(loc);

    for (List<Integer> orient : ListSequence.fromList(orientation).subListSequence(1, ListSequence.fromList(orientation).count())) {
      boolean found = false;
      for (List<Integer> location : ListSequence.fromList(locations)) {
        // if np.array_equal(np.add(loc, np.subtract(orient, fix)), np.array(location)):
        if (check_orientation_fit_at_loc_with_fix(loc, orient, fix, location)) {
          found = true;
          ListSequence.fromList(embedded).addElement(location);
          break;
        }
      }
      if (!(found)) {
        return ListSequence.fromList(new ArrayList<List<Integer>>());
      }
    }
    return embedded;
  }

  private boolean check_orientation_fit_at_loc_with_fix(List<Integer> loc, List<Integer> orient, List<Integer> fix, List<Integer> location) {
    // np.array_equal(np.add(loc, np.subtract(orient, fix)), np.array(location))
    int[] loc_plus_orient_minus_fix = new int[ListSequence.fromList(orient).count()];
    for (int i = 0; i < ListSequence.fromList(orient).count(); i++) {
      loc_plus_orient_minus_fix[i] = ListSequence.fromList(orient).getElement(i) - ListSequence.fromList(fix).getElement(i) + ListSequence.fromList(loc).getElement(i);
    }
    // Oh no is this going to be super slow? Surprisingly, no.
    for (int i = 0; i < loc_plus_orient_minus_fix.length; i++) {
      if (loc_plus_orient_minus_fix[i] != ListSequence.fromList(location).getElement(i)) {
        return false;
      }
    }
    return true;
  }

  private List<List<Integer>> mapLocationsToListOfInts(List<SNode> locations) {
    List<List<Integer>> locs = ListSequence.fromList(new ArrayList<List<Integer>>());
    for (SNode location : ListSequence.fromList(locations)) {
      List<Integer> loc = ListSequence.fromList(new ArrayList<Integer>());
      for (SNode coordinate : ListSequence.fromList(SLinkOperations.getChildren(location, LINKS.coordinates$48xZ))) {
        ListSequence.fromList(loc).addElement(SPropertyOperations.getInteger(coordinate, PROPS.coordinate$hw$O));
      }
      ListSequence.fromList(locs).addElement(loc);
    }
    return locs;
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink shape$f2Vs = MetaAdapterFactory.getReferenceLink(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37abf69bL, 0x2cd4be37adec52L, "shape");
    /*package*/ static final SContainmentLink locations$c$Xv = MetaAdapterFactory.getContainmentLink(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37ada4e2L, 0x2cd4be37adcd2bL, "locations");
    /*package*/ static final SReferenceLink piece$jZYy = MetaAdapterFactory.getReferenceLink(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37ae02bdL, 0x2cd4be37ae080fL, "piece");
    /*package*/ static final SContainmentLink locations$ChQi = MetaAdapterFactory.getContainmentLink(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37ae0ae9L, 0x2cd4be37ae0e94L, "locations");
    /*package*/ static final SContainmentLink aspects$q3wJ = MetaAdapterFactory.getContainmentLink(0xf18355ad2d424a0aL, 0xa78566932d080030L, 0x4eaa6535d7c8b4ebL, 0x4eaa6535d7c8b814L, "aspects");
    /*package*/ static final SContainmentLink orientations$BxMn = MetaAdapterFactory.getContainmentLink(0x31e3a3f93c6d4ff3L, 0x835b963db6c69f0aL, 0x259fd626a2ac2732L, 0x259fd626a2add54bL, "orientations");
    /*package*/ static final SReferenceLink bagofpieces$Ua4q = MetaAdapterFactory.getReferenceLink(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37abf69bL, 0x2cd4be37adea14L, "bagofpieces");
    /*package*/ static final SContainmentLink pieces$2_Tv = MetaAdapterFactory.getContainmentLink(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37ada031L, 0x2cd4be37aed1a3L, "pieces");
    /*package*/ static final SContainmentLink coordinates$48xZ = MetaAdapterFactory.getContainmentLink(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37adb89fL, 0x2cd4be37aee65fL, "coordinates");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty allowed$EpHE = MetaAdapterFactory.getProperty(0x31e3a3f93c6d4ff3L, 0x835b963db6c69f0aL, 0x259fd626a2addc02L, 0x259fd626a2ade26cL, "allowed");
    /*package*/ static final SProperty multiplicity$Equw = MetaAdapterFactory.getProperty(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37ae02bdL, 0x2cd4be37ae0492L, "multiplicity");
    /*package*/ static final SProperty coordinate$hw$O = MetaAdapterFactory.getProperty(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37adda67L, 0x2cd4be37adde2aL, "coordinate");
  }
}
