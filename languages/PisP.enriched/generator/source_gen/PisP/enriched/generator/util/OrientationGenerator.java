package PisP.enriched.generator.util;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.baseLanguage.logging.rt.LogContext;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class OrientationGenerator {
  private class Matrix {
    private List<int[]> m;

    private Matrix(int[][] m) {
      this.m = Sequence.fromIterable(Sequence.fromArray(m)).toListSequence();
    }

    private Matrix(List<int[]> m) {
      this.m = m;
    }

    private Matrix(Matrix M) {
      this.m = M.m;
    }

    private Matrix(SNode p) {
      List<int[]> A = ListSequence.fromList(new ArrayList<int[]>());

      for (SNode loc : ListSequence.fromList(SLinkOperations.getChildren(p, LINKS.locations$ChQi))) {
        // Each location becomes a row
        int[] row = new int[ListSequence.fromList(SLinkOperations.getChildren(loc, LINKS.coordinates$48xZ)).toGenericArray(SNode.class).length];
        int i = 0;
        for (SNode coo : ListSequence.fromList(SLinkOperations.getChildren(loc, LINKS.coordinates$48xZ))) {
          row[i++] = SPropertyOperations.getInteger(coo, PROPS.coordinate$hw$O);
        }
        ListSequence.fromList(A).addElement(row);
      }
      this.m = A;
    }

    public Matrix multiply(Matrix m) {
      List<int[]> A = this.m;
      List<int[]> B = m.m;
      List<int[]> C = ListSequence.fromList(new ArrayList<int[]>());
      // A*B=C
      // loop over rows of A
      for (int r = 0; r < ListSequence.fromList(A).count(); r++) {
        // loop over cols of B
        ListSequence.fromList(C).addElement(new int[ListSequence.fromList(B).getElement(0).length]);
        for (int c = 0; c < ListSequence.fromList(B).getElement(0).length; c++) {
          // dot product
          int dot = 0;
          for (int i = 0; i < ListSequence.fromList(B).count(); i++) {
            dot += ListSequence.fromList(A).getElement(r)[i] * ListSequence.fromList(B).getElement(i)[c];
          }
          ListSequence.fromList(C).getElement(r)[c] = dot;
        }
      }
      return new Matrix(C);
    }

    public List<SNode> toLocations() {
      List<SNode> locs = ListSequence.fromList(new ArrayList<SNode>());
      // For each row in matrix, make a location
      for (int[] r : this.m) {
        SNode loc = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37adb89fL, "PisP.structure.Location"));
        for (int c : r) {
          SNode coo = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37adda67L, "PisP.structure.Coordinate"));
          SPropertyOperations.assign(coo, PROPS.coordinate$hw$O, c);
          ListSequence.fromList(SLinkOperations.getChildren(loc, LINKS.coordinates$48xZ)).addElement(coo);
        }
        ListSequence.fromList(locs).addElement(loc);
      }
      return locs;
    }
  }

  public List<SNode> generateOrientations(SNode piece) {
    switch (SPropertyOperations.getEnum(piece, PROPS.lattice$e_Fj).getName()) {
      case "CubicLattice2D":
        return generateOrientations(piece, isometries2DCubic());
      case "CubicLattice3D":
        return generateOrientations(piece, isometries3DCubic());
      case "FCCLattice":
        return generateOrientations(piece, isometriesFCC());
      default:
        LogContext.with(OrientationGenerator.class, null, null).debug("OrientationGenerator: lattice " + SPropertyOperations.getEnum(piece, PROPS.lattice$e_Fj).getName() + " not implemented.");
        assert false;
    }
    return null;
  }

  private List<SNode> generateOrientations(SNode piece, List<Matrix> isometries) {
    List<SNode> orientations = ListSequence.fromList(new ArrayList<SNode>());
    Matrix p = new Matrix(piece);
    int i = 0;
    for (Matrix m : ListSequence.fromList(isometries)) {
      SNode o = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x31e3a3f93c6d4ff3L, 0x835b963db6c69f0aL, 0x259fd626a2addc02L, "PisP.enriched.structure.Orientation"));
      SPropertyOperations.assign(o, PROPS.allowed$EpHE, true);
      SPropertyOperations.assignEnum(o, PROPS.lattice$e_Fj, SPropertyOperations.getEnum(piece, PROPS.lattice$e_Fj));
      SPropertyOperations.assign(o, PROPS.name$MnvL, SPropertyOperations.getString(piece, PROPS.name$MnvL) + i++);
      ListSequence.fromList(SLinkOperations.getChildren(o, LINKS.locations$ChQi)).addSequence(ListSequence.fromList(p.multiply(m).toLocations()));
      ListSequence.fromList(orientations).addElement(o);
    }
    return orientations;
  }

  private List<Matrix> isometries2DCubic() {
    List<Matrix> result = ListSequence.fromList(new ArrayList<Matrix>());
    int[][] tempB = {{1, 0}, {0, 1}};
    Matrix basis = new Matrix(tempB);
    int[][] tempRot = {{0, -1}, {1, 0}};
    Matrix rot = new Matrix(tempRot);
    int[][] tempRef = {{1, 0}, {0, -1}};
    Matrix ref = new Matrix(tempRef);
    for (int i = 0; i < 4; i++) {
      basis = basis.multiply(rot);
      ListSequence.fromList(result).addElement(basis);
    }
    basis = basis.multiply(ref);
    for (int i = 0; i < 4; i++) {
      basis = basis.multiply(rot);
      ListSequence.fromList(result).addElement(basis);
    }
    return result;
  }

  private List<Matrix> isometries3DCubic() {
    List<Matrix> result = ListSequence.fromList(new ArrayList<Matrix>());
    int[][] basisi = {{-1, 0, 0}, {1, 0, 0}, {0, -1, 0}, {0, 1, 0}, {0, 0, -1}, {0, 0, 1}};
    // Dumb version because I am not generating permutations with itertools
    for (int ix = 0; ix < 3; ix++) {
      for (int iy = 0; iy < 3; iy++) {
        if (ix == iy) {
          continue;
        }
        for (int iz = 0; iz < 3; iz++) {
          if (ix == iz || iy == iz) {
            continue;
          }
          for (int sx = -1; sx <= 1; sx += 2) {
            for (int sy = -1; sy <= 1; sy += 2) {
              for (int sz = -1; sz <= 1; sz += 2) {
                int det = sx * sy * sz;
                int[] coeffs = {ix, iy, iz};
                if (!(isLoop(coeffs))) {
                  det *= -1;
                }
                if (det == 1) {
                  // Only allow orientation preserving isometries
                  int a = (sx > 0 ? 2 * (ix + 1) - 1 : 2 * ix);
                  int b = (sy > 0 ? 2 * (iy + 1) - 1 : 2 * iy);
                  int c = (sz > 0 ? 2 * (iz + 1) - 1 : 2 * iz);
                  int[][] m = {basisi[a], basisi[b], basisi[c]};
                  ListSequence.fromList(result).addElement(new Matrix(m));
                }
              }
            }
          }
        }
      }
    }
    assert ListSequence.fromList(result).count() == 24;
    return result;
  }

  private boolean isLoop(int[] ns) {
    int prev = ns[ns.length - 1];
    for (int n : ns) {
      if (n == 0) {
        prev = n;
        continue;
      }
      if (n - prev != 1) {
        return false;
      }
      prev = n;
    }
    return true;
  }

  private List<Matrix> isometriesFCC() {
    List<Matrix> result = ListSequence.fromList(new ArrayList<Matrix>());
    // 'X'.join(legacy.split("\n"))
    // yield np.array([list(map(lambda s: int(s), n[2:len(n)-1].split(","))) for n in m[2:len(m)-3].split("/")])
    String legacy = "  ( 0, 1, 0)/( 0, 0, 1)/(-1,-1,-1)Y-1X  ( 0, 0, 1)/( 0, 1, 0)/(-1,-1,-1)Y1X  ( 0, 0,-1)/( 0,-1, 0)/(-1, 0, 0)Y1X  ( 0,-1, 0)/( 0, 0,-1)/(-1, 0, 0)Y-1X  ( 1, 0, 0)/( 0, 0, 1)/(-1,-1,-1)Y1X  ( 1, 0, 0)/( 0, 1, 0)/(-1,-1,-1)Y-1X  ( 1, 1, 1)/( 0,-1, 0)/(-1, 0, 0)Y-1X  ( 1, 1, 1)/( 0, 0,-1)/(-1, 0, 0)Y1X  ( 0, 0, 1)/( 1, 0, 0)/(-1,-1,-1)Y-1X  ( 0, 1, 0)/( 1, 0, 0)/(-1,-1,-1)Y1X  ( 0,-1, 0)/( 1, 1, 1)/(-1, 0, 0)Y1X  ( 0, 0,-1)/( 1, 1, 1)/(-1, 0, 0)Y-1X  ( 0, 0,-1)/(-1, 0, 0)/( 0,-1, 0)Y-1X  ( 0, 1, 0)/(-1,-1,-1)/( 0, 0, 1)Y1X  ( 0,-1, 0)/(-1, 0, 0)/( 0, 0,-1)Y1X  ( 0, 0, 1)/(-1,-1,-1)/( 0, 1, 0)Y-1X  ( 1, 1, 1)/(-1, 0, 0)/( 0,-1, 0)Y1X  ( 1, 0, 0)/(-1,-1,-1)/( 0, 0, 1)Y-1X  ( 1, 1, 1)/(-1, 0, 0)/( 0, 0,-1)Y-1X  ( 1, 0, 0)/(-1,-1,-1)/( 0, 1, 0)Y1X  (-1, 0, 0)/( 0, 0,-1)/( 0,-1, 0)Y1X  (-1, 0, 0)/( 0,-1, 0)/( 0, 0,-1)Y-1X  (-1,-1,-1)/( 0, 1, 0)/( 0, 0, 1)Y-1X  (-1,-1,-1)/( 0, 0, 1)/( 0, 1, 0)Y1X  ( 1, 1, 1)/( 0, 0,-1)/( 0,-1, 0)Y-1X  ( 1, 1, 1)/( 0,-1, 0)/( 0, 0,-1)Y1X  ( 1, 0, 0)/( 0, 1, 0)/( 0, 0, 1)Y1X  ( 1, 0, 0)/( 0, 0, 1)/( 0, 1, 0)Y-1X  (-1, 0, 0)/( 1, 1, 1)/( 0,-1, 0)Y-1X  (-1,-1,-1)/( 1, 0, 0)/( 0, 0, 1)Y1X  (-1, 0, 0)/( 1, 1, 1)/( 0, 0,-1)Y1X  (-1,-1,-1)/( 1, 0, 0)/( 0, 1, 0)Y-1X  ( 0, 0,-1)/( 1, 1, 1)/( 0,-1, 0)Y1X  ( 0, 1, 0)/( 1, 0, 0)/( 0, 0, 1)Y-1X  ( 0,-1, 0)/( 1, 1, 1)/( 0, 0,-1)Y-1X  ( 0, 0, 1)/( 1, 0, 0)/( 0, 1, 0)Y1X  ( 0, 0, 1)/(-1,-1,-1)/( 1, 0, 0)Y1X  ( 0, 1, 0)/(-1,-1,-1)/( 1, 0, 0)Y-1X  ( 0,-1, 0)/(-1, 0, 0)/( 1, 1, 1)Y-1X  ( 0, 0,-1)/(-1, 0, 0)/( 1, 1, 1)Y1X  (-1,-1,-1)/( 0, 0, 1)/( 1, 0, 0)Y-1X  (-1,-1,-1)/( 0, 1, 0)/( 1, 0, 0)Y1X  (-1, 0, 0)/( 0,-1, 0)/( 1, 1, 1)Y1X  (-1, 0, 0)/( 0, 0,-1)/( 1, 1, 1)Y-1X  ( 0, 1, 0)/( 0, 0, 1)/( 1, 0, 0)Y1X  ( 0, 0, 1)/( 0, 1, 0)/( 1, 0, 0)Y-1X  ( 0, 0,-1)/( 0,-1, 0)/( 1, 1, 1)Y-1X  ( 0,-1, 0)/( 0, 0,-1)/( 1, 1, 1)Y1";
    for (String line : legacy.split("X")) {
      String[] matr_det = line.trim().split("Y");
      int det = Integer.parseInt(matr_det[1]);
      if (det == 1) {
        List<int[]> m = ListSequence.fromList(new ArrayList<int[]>());
        ListSequence.fromList(m).addElement(new int[3]);
        ListSequence.fromList(m).addElement(new int[3]);
        ListSequence.fromList(m).addElement(new int[3]);
        int j = 0;
        for (String col : matr_det[0].split("/")) {
          int i = 0;
          for (String c : col.substring(1, col.length() - 1).split(",")) {
            ListSequence.fromList(m).getElement(i)[j] = Integer.parseInt(c.trim());
            i++;
          }
          j++;
        }
        ListSequence.fromList(result).addElement(new Matrix(m));
      }
    }
    assert ListSequence.fromList(result).count() == 24;
    return result;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink coordinates$48xZ = MetaAdapterFactory.getContainmentLink(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37adb89fL, 0x2cd4be37aee65fL, "coordinates");
    /*package*/ static final SContainmentLink locations$ChQi = MetaAdapterFactory.getContainmentLink(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37ae0ae9L, 0x2cd4be37ae0e94L, "locations");
  }

  private static final class PROPS {
    /*package*/ static final SProperty coordinate$hw$O = MetaAdapterFactory.getProperty(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37adda67L, 0x2cd4be37adde2aL, "coordinate");
    /*package*/ static final SProperty lattice$e_Fj = MetaAdapterFactory.getProperty(0x9ea5405ccd504139L, 0x8b0811b78b688cf5L, 0x2cd4be37ae0ae9L, 0x2cd4be37af4f8fL, "lattice");
    /*package*/ static final SProperty allowed$EpHE = MetaAdapterFactory.getProperty(0x31e3a3f93c6d4ff3L, 0x835b963db6c69f0aL, 0x259fd626a2addc02L, 0x259fd626a2ade26cL, "allowed");
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
